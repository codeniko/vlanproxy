---------------------------------------------
GROUP MEMBERS
---------------------------------------------
Nikolay Feldman (nf139)
Harvinder Singh (sharv)



---------------------------------------------
GROUP MEMBER RESPONSIBILITIES
---------------------------------------------
Nikolay Feldman:
	printHelp()
	handle_public()
	handle_private()
	Making pthread work
	handle_signal()


Harvinder Singh: 
	createSocket()
	createConnections()
	allocate_tunnel() - given


This is what it was split to but we both touched on each other's functions.


---------------------------------------------
GENERAL ARCHITECTURE OF PROGRAM
---------------------------------------------
Before any work is done, the File Descriptors for the private (tap) interface and the public socket must be obtained. There is a global struct pointer which all functions have access to, which when malloc'ed, holds these File Descriptors and the various other info needed to have functions working properly (handles). Once the proxies establish a connection between each other over a public interface, the private interface seems to be connected between the machines too (because of the tunnel). The program then creates 2 threads to handle the read/write functionality of both the private and public interfaces. When the program is finished or a type of TERMINATE signal is sent, there is a signal handler that catches it, and actually write ONE MORE packet to the remote proxy. The proxy contains a custom message which causes the remote proxy to terminate as well (gracefully).



---------------------------------------------
FUNCTIONS AND WHAT THEY DO AND HOW THEY WORK
---------------------------------------------
main(int argc, char **argv)
	Create space in memory for the ProxyInfo struct. Add signal handlers for SIGHUP,SIGINT,SIGPIPE,SIGALRM,SIGTERM,SIGUSR1, and SIGUSR2. Based on the number of the arguments, determine if local proxy is a SERVER or CLIENT. Call a sequence of other functions to establish a socket connection and finally create threads to handle read/write to the public/private interfaces

printHelp()
	If there is an invalid input when invoking the program, this function will print the correct usage.

handle_signal(int sig)
	If a termination signal was sent to the program, handle it here by cancelling both threads (if active), closing all file descriptors and freeing memory. Whichever proxy receives the terminating signal, this proxy will send a custom message to the remote proxy to gracefully terminate that one as well. Both Proxies terminate at roughly the same time.

allocate_tunnel(char *dev, int flags)
	Open the private interface device and return its file descriptor. This function was given to us in the Project Description.

createSocket(char *host, int port)
	Create a socket by specifying the host and port number for the socket address. A lot of the code here was given in the Project Description. Return a file descriptor onces the socket is created as a SOCK_STREAM and uses the TCP protocol

createConnection()
	Create a connection between 2 proxies on a public interface. If server, listen for a client to connect. If client, attempt to connect to the server. Once the connection is established, a boolean is switched to true indicating that we have an active connection.

handle_public(void *arg)
	A thread that indefinitely reads from the socket, receives an encapsulated message with 4 bytes of headers (tag/length), and writes the decapsulated message to the private interface (tap) of the local machine. It works by creating a buffer, filling it by reading from the socket, and sending it to the private interface if the entire message is in the buffer. The messages it accepts must contain the tag 0xABCD in the encapsulated header. Occasionally, the buffer actually reads more data than the length of the message in the header. The partial buffer is sent to the private interface and the remaining bytes that was extra is rewritten to the beginning of the buffer. The loop continues and sends the remaining data. If the message is incomplete (the length in the header > the number of actual bytes in the buffer), then the program reads the remaining length and adds it to the buffer after the incomplete portion. Finally, we also check for the custom TERMINATE message to arrive here IF the message length is equal to the message length of the TERMINATION phrase. If the lengths are equal, then the message is read and compared in order to confirm TERMINATION. Once confirmed, the proxy gracefully exits by calling handle_signal(-1). The argument value of -1 will tell the handler to NOT send a termination message back to the other proxy.

handle_private(void *arg)
	A thread that indefinitely reads from the tap interface, receives a raw message, encapsulates the message with 4 bytes of headers (tag/length), and writes to the socket. This one is more simple than the socket handler as all it does is read, encapsulate, and write back out. There are very few things that can happen wrong here.



---------------------------------------------
DIFFICULTIES
---------------------------------------------
We learned a LOT from this assignment. Neither of us did any sort of socket programming before and this was a really interesting awakening. We also never used pthread before, nor did we ever use signal handlers. A lot of the code was provided to us and the code to establish a connection between client/server was in the lecture slides. The most difficult part was actually implementing the threads that read/write packets, more specifically the public interface socket one. The idea was simple at first, read, decapsulate, and then write. It worked VERY well for packets that were below ~2048 bytes (buffer size). However, things got really complicated when we tried pinging with size greater than that. Read/Write actually read/wrote in fragments, and EVEN read an ENTIRE 2048 byte buffer size when the message length was actually significally smaller. Basically, it was reading too much and we had to handle that. It took a lot of brainstorming and a lot of head scratching while drawing out the different scenarios that was happening on a white board. We tried to visually simulate it on the board so that we can try to understand what happens, and what we can do to get all the messages correctly. In the end, everything seems to be working fine. The only thing left open is maybe a different way to gracefully terminate the remote proxy when the local proxy is terminated. It is DEFINITELY possible to have a message from some application that actually looks identical and of identical length to the our terminating message. Although the change of that happening is EXTREMELY small.
